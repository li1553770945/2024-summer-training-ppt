---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0829 讲题

---

## \[ABC208-A\]滚动骰子

<br>



### 题意

给定两个整数 $A$ 和 $B$，判断通过 $A$ 次掷骰子，是否可能得到总和为 $B$ 的结果。每次掷骰子的结果范围是 1 到 6。

### 题解


- **范围判断法**：考虑 $A$ 次掷骰子可能得到的最小和最大值。
  - 最小值：如果每次都掷出1，总和为 $A$。
  - 最大值：如果每次都掷出6，总和为 $6A$。
  - 只需检查 $B$ 是否在这个范围 \[$A$, $6A$\] 内。


---

## \[ABC208-B\]阶乘日元硬币

<br>


### 题意

给定一个整数 $P$，表示商品的价格，需要使用从 $1!$ 到 $10!$ 的硬币（每种各 100 枚）来支付。要求输出最少需要的硬币数量，以确切支付这个价格。

### 题解

#### 思路

- **硬币种类有限**：给定的硬币类型是 $1!$ 到 $10!$，每种硬币价值递增且每种硬币数量充足（100枚），可以用贪心算法从最大面值开始使用，尽可能减少硬币使用数量。

#### 关键步骤

1. **计算所有硬币面值**：首先计算出 $1!$ 到 $10!$ 的硬币的价值。
2. **逆序遍历硬币**：从面值最大的硬币开始，尽可能多地使用，直到无法使用更多为止，然后转向次大的硬币。
3. **累计硬币数量**：在每次使用硬币后更新剩余金额，并计数已使用的硬币数量。
4. **输出结果**：输出累计的硬币数量，这将是确切支付 $P$ 日元所需的最少硬币数。


---

## \[ABC208-C\]公平糖果分配

<br>


### 题意

给定 $N$ 个不同的身份证号码和 $K$ 个糖果。首先，如果糖果足够多，按每人一块分发给所有人。当糖果不足以给每个人分配一块时，按照身份证号码的大小顺序分配给身份证号最小的几位公民。任务是计算最终每个公民收到的糖果数量。

### 题解

#### 思路

为了公平高效地分配糖果，我们需要考虑两种情况：完整分发和剩余分发。完整分发是指当糖果足够时，每人至少能分到相同数量的糖果。剩余分发则针对糖果不够每人一块的情况，此时需依据身份证号的大小优先分配。为了方便处理这种优先级分配，先对身份证号进行排序。

---

#### 关键步骤

1. **读取输入和初始化**：读取公民数量 $N$ 和糖果数量 $K$，并获取每个公民的身份证号。
2. **排序身份证号**：将公民按其身份证号排序，以便后续按序分配剩余糖果。
3. **计算和分配糖果**：
   - 确定可以均匀分配的轮数 $full\_rounds = \lfloor K/N \rfloor$。
   - 计算分配完整轮次后剩余的糖果 $remaining\_candy = K \mod N$。
   - 按已确定的轮数给每个公民分配糖果。
   - 将剩余的糖果按身份证号顺序分配给对应的公民。
4. **输出结果**：根据公民的原始顺序输出他们获得的糖果数量。

---

## \[ABC208-D\]最短路径查询2

<br>


### 题意

给定一个包含 $N$ 个城市和 $M$ 条单向道路的高桥王国，城市编号从 $1$ 到 $N$，每条道路具有一个通过时间。定义 $f(s, t, k)$ 为从城市 $s$ 到城市 $t$ 在只经过编号从 $1$ 到 $k$ 的城市的条件下的最短路径时间。若无法到达或 $s=t$，则 $f(s, t, k)=0$。求所有可能的三元组 $(s, t, k)$ 对应的 $f(s, t, k)$ 之和。

### 解法

[Floyd算法](https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95)的模板题。



1. 初始化所有城市对的最短路径长度，如果两个城市之间有直接的道路，则其距离为道路长度，否则为无穷大（除了对角线元素为0，表示城市自身到自身的距离）。

2. 按照节点编号 $k$ 逐一加入，更新所有城市对 $s, t$ 的最短路径，这里的更新考虑通过节点 $k$ 是否能够使得 $s$ 到 $t$ 的距离更短。

3. 每次更新完成后，累计加入当前得到的最短路径，即对于每个 $k$，计算 $\sum_{s=1}^{N}\sum_{t=1}^{N} f(s, t, k)$。

4. 这样，当所有节点都考虑完毕后，我们就可以得到所有 $(s, t, k)$ 对应的 $f(s, t, k)$ 之和。



---

##  \[ABC209-E\]词语接龙

<br>


### 题意

A 和 B 在玩单词接龙的游戏，每次接龙的单词必须满足一个条件，即后一个人说的单词的前 3 个字母必须与前一个人说的单词的后 3 个字母相同。在这个游戏中，每个人都采用最优策略。我们需要确定，如果 A 最开始说给出的第 i 个单词，最终谁会获胜。

### 解法

一个单词如果没有其他单词可以接上，那么该单词处于必败状态。相反，如果一个状态可以导向对手的必败状态，则该状态为必胜状态；如果一个状态全部导向对手的必胜状态，则该状态为必败状态。

---

1. **建图**：把游戏抽象为一个图，节点代表单词，有向边连接可以依照游戏规则相连的单词。

直接连接是 $O(n^2)$ 的，显然会超时。

题目中告诉我们，每一个单词可以无限用，而且单词也只需要知道前三个和后三个，不用知道具体是什么。

可以使用哈希。对于三个字符 $a,b,c$，定义映射 $F(a,b,c)$ 为 $(a - 'A') \times 256^2 + (b - 'A') \times 256 + (c - 'A')$。

定义一个 map：$G(x)$。其中每访问到一个新的 $x$，$G(x)$ 就是一个新的数。

对于每一个字符，取出前三个字符 $a,b,c$ 和后三个字符 $x,y,z$，$G(F(x,y,z))$ 向 $G(F(a,b,c))$ 连边。

+ 当一个点连向的点中有一个必胜态，则这个点是必败态。
+ 当一个点连向的点都是必败态，则这个点是必胜态。

---

2. **反向推理使用 BFS**：从不能继续的单词（即必败状态的单词）开始，使用广度优先搜索（BFS），类似于拓扑排序，逆向传播这些状态。
3. 
注意到我们是从必败态向前推的，因此本题可以**反向建图**。


定义一个数组f，如果是1 代表 a 赢，是$-1$ 代表 b 赢，是0 代表平局。

初始化所有没有入边的点为1，并且把这些点加入到队列，然后从这些点开始BFS。


---

## 

<br>


### 题意


### 解法
