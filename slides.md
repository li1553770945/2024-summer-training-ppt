---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0812 讲题

---

## \[ABC187-A\]大数字

<br> 


### 题意

给定两个三位数的整数$A$和$B$，需要找出这两个数各自数字之和中的较大者。如果两者相等，则输出$A$的数字之和。


### 解法

1. 计算整数$A$和$B$的数字之和$S(A)$和$S(B)$。这可以通过对每个数进行模$10$和整除$10$的操作循环得到。
2. 比较$S(A)$和$S(B)$，输出较大的那个数的数字之和。如果$S(A) = S(B)$，则输出$S(A)$。

---

## \[ABC186-B\]网格上的块

<br>


### 题意

给定一个由 $H$ 行和 $W$ 列组成的网格，每个方格有一定数量的块。求最少需要移除多少块使所有方格的块数相同。


### 解法

1. 首先，读取整个网格的数据，并找出所有方格中的最小块数。
2. 然后，计算将每个方格的块数降低到最小块数所需移除的块数总和。

---

## \[ABC186-C\]不幸的7

<br>


### 题意

给定一个整数$N$，找出从1到$N$（含）之间既不在十进制表示中包含数字7，也不在八进制表示中包含数字7的整数的数量。

### 解法

1. 对每个整数$i$从1到$N$，检查其十进制和八进制表示是否包含数字7。这可以通过不断除以10或8并检查余数是否为7来实现。

2. 计数所有满足条件的整数，并输出这个数量。


---

## \[ABC186-D\]差异总和

<br>


### 题意

给定一组整数，计算所有可能的整数对之间的绝对差值的总和。

### 解法

简单做法：直接用$n^2$遍历所有的数对。




---

## \[ABC186-D\]差异总和

<br>


1. **排序**：首先将整数数组进行排序。排序后，数组中的每个元素将会与它之后的元素形成一个升序对，这样可以直接计算差值而不需要关心差的正负。

2. **利用前缀和优化差值计算**：通过单次遍历配合前缀和技术计算差值总和。具体步骤如下：
   - 初始化一个变量 `ans` 用于存储总差值和，另一个变量 `sum_prefix` 用于累计到当前遍历位置的所有元素之和。
   - 遍历数组中的每个元素（从第二个元素开始），对于当前元素 `a[j]`，其与之前所有元素的差的总和可以表示为：`a[j]` 乘以其位置索引减 1（即$j-1$，前面有多少个数与它形成对）减去 `sum_prefix`（即与它形成数对的所有元素的总和）,$ans += a[j] \times (j-1) - sum\_prefix$
   - 更新 `sum_prefix` ,加上当前元素 `a[j]` 的值。
   - 这样，每次循环可以在 O(1) 的时间复杂度内计算出当前元素与之前所有元素的差的总和，从而避免了嵌套循环，大大提高了效率。

3. **输出结果**：遍历完成后，`ans` 中存储的就是所求的所有整数对的绝对差值总和，最后输出该值。

---

## \[ABC186-E\]宝座

<br>


### 题意

在围成一圈的$N$把椅子中，其中一把是王座。一个人从王座顺时针数第$S$个位置起始，每次向前移动$K$个位置。问他第一次坐到王座上需要多少次移动，如果无法坐到王座上则返回-1。


### 解法

令 $X$ 为移动次数，$Y$ 为移动圈数，则有：

$$
XK + S = YN
$$

从而我们得到以下方程：

$$
YN - XK = S
$$

这是一个典型的同余方程。这里可以利用扩展欧几里得算法（Extended GCD）先求解得到：


---


### 解方程 $YN - XK = S$

1. **计算 GCD 和基本解**：首先，使用扩展欧几里得算法找到$Y'$ 和$X'$使得
  $$
   Y'N + X'K = \gcd(N, K)
  $$
   这为我们提供了满足最简形式的基本解。

2. **检查$S$是否可行**：如果
  $$
   S \% \gcd(N, K) \neq 0
  $$
   那么没有解，因为$S$不能被$\gcd(N, K)$整除。

3. **调整比例**：如果$S$可以被$\gcd(N, K)$整除，那么将$Y'$和$X'$乘以
  $$
   \frac{S}{\gcd(N, K)}
  $$
   将提供$YN - XK = S$的一个解。

这样，原方程的解就可以通过调整扩展欧几里得算法得到的基本解来找到。


---

## \[ABC186-F\]网格上的车

<br>


### 题意

我们有一个带障碍的网格，网格的起点在$(1,1)$处有一个象棋中的车。需要计算这个车在两步或两步以内能到达多少个方格。


### 解法


1. 维护每一行和每一列的第一个障碍物的位置：
   - `r[i]` 表示第 $i$ 行的第一个障碍物列下标。
   - `c[i]` 表示第 $i$ 列的第一个障碍物行下标。

2. 计算能直接到达的格子数：
   - 对于列 `[1, c[1]-1]` 的每一行，车可以直接到达的格子数为 `r[i]-1`。
   - 对于行 `[1, r[1]-1]` 的每一列，车可以直接到达的格子数为 `c[i]-1`。



--- 

3. 消除重复统计的格子：
   - 需要从总数中减去重复统计的格子数。
   - 例如，在统计第 $i$ 列时，本来应累加 `c[i]-1`，重复的格子数是第 `1` 到 `c[i]-1` 行中 `r[] > i` 的行数，不重复的格子数即为满足 `r[] \leq i` 的行数。

4. 快速统计满足条件的行数：
   - 将 $(r[k], k)$ 按照 $r[]$ 从小到大排序。
   - 枚举每列 $i$，使用树状数组存储 $k$ 值，通过查询 `1` 到 `c[i]-1` 的前缀和，快速得到不重复格子的数量。

这种方法通过精细的索引和前缀和的应用，高效地处理了大量数据，避免了直接模拟带来的复杂度问题。
