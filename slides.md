---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0816 讲题

---

## \[ABC194-A\]我尖叫

<br>


### 题意

在日本，冰淇淋类产品根据乳固体和乳脂的含量分为四种：冰淇淋、冰奶、乳冰和调味冰。根据乳固体总含量和乳脂含量的不同标准，每种产品有明确的定义。输入给定的是非脂乳固体和乳脂的百分比，需要判断该产品属于哪一类。

### 题解

1. **计算总乳固体含量**：首先计算总乳固体含量，这是非脂乳固体和乳脂含量的总和，即$total\_milk\_solid = A + B$。
2. **分类判断**：
   - **冰淇淋**：如果总乳固体含量不小于$15\%$且乳脂含量不小于$8\%$，则产品为冰淇淋。
   - **冰奶**：如果不符合冰淇淋的条件，但总乳固体含量不小于$10\%$且乳脂含量不小于$3\%$，则产品为冰奶。
   - **乳冰**：如果不符合以上两者的条件，但总乳固体含量不小于$3\%$，则产品为乳冰。
   - **调味冰**：如果以上条件都不满足，则产品为调味冰。
3. **输出相应的分类编号**：根据上述条件判断，输出对应的分类编号。


---

## \[ABC194-B\]工作分配

<br>


### 题意

你的公司有$N$名员工，编号从$1$到$N$。有两个工作任务，分别是工作A和工作B，需要分配给这些员工完成。每个员工完成工作A和工作B所需的时间分别是$A_i$分钟和$B_i$分钟。你可以将两个工作分配给同一个员工，也可以分配给两个不同的员工。目标是找到完成这两项工作的最短时间。

### 解法

1. **数据读取与初始化**：读取员工数量$N$和每个员工完成两项工作所需的时间，存储为两个数组`a`和`b`，每个数组包含时间和员工索引。
2. **排序**：对两个数组进行升序排序，以便快速访问完成每项工作最快的员工。
   
---

3. **最优分配策略**：
   - 如果完成工作A和B最快的是同一员工，比较：
     - 该员工同时完成两项任务的总时间$a[0].first + b[0].first$。
     - 分配工作A给最快员工，工作B给次快员工的时间$\max(b[1].first, a[0].first)$。
     - 分配工作B给最快员工，工作A给次快员工的时间$\max(a[1].first, b[0].first)$。
     - 选择上述时间中的最小值作为结果。
   - 如果不是同一个员工，选择两项工作分别由不同员工完成所需的最大时间$\max(a[0].first, b[0].first)$。
4. **输出结果**：输出计算得到的最短完成时间。
   
由于$N$的范围很小只有一千，也可以直接枚举。

---

##  \[ABC194-C\]平方误差

<br>


### 题意

给定一个长度为 $N$ 的整数数组 $A$，求每对元素 $A_i$ 和 $A_j$（其中 $i > j$）之间平方差的总和。


### 解法

为了避免 $O(N^2)$ 的时间复杂度，我们可以通过数学变形和累积总和的方式来优化计算。主要思想是预先计算和存储所有先前元素的累加和与平方和，利用这些累积值来快速计算每个新元素与所有先前元素的平方差。

考虑到平方差的定义：

$(A_i - A_j)^2 = A_i^2 - 2A_iA_j + A_j^2$

对于每个 $i$，要计算其与前 $i-1$ 个元素的平方差之和，可以重写为：

$\sum_{j=1}^{i-1}(A_i - A_j)^2 = \sum_{j=1}^{i-1}(A_i^2 - 2A_iA_j + A_j^2)$ 

--- 

这可以进一步简化并分开计算为三部分：
1. $A_i^2$ 乘以 $(i-1)$（因为每个 $A_j$ 都会贡献一个 $A_i^2$）
2. $-2A_i$ 乘以前 $i-1$ 个元素的和
3. 前 $i-1$ 个元素的平方和

即： $A_i^2 \times (i-1) - 2A_i \times \sum_{j=1}^{i-1}  A_j + \sum_{j=1}^{i-1} A_j^2$

我们可以维护 `sum` 和 `sum_squares` 两个累积值。通过预存这些值，我们可以将每次的计算降低到 $O(1)$，从而整体上将算法的时间复杂度降低到 $O(N)$。

---

1. **初始化变量**：
   - `sum`：用于累加前面所有元素的和。
   - `sum_squares`：用于累加前面所有元素的平方和。
   - `result`：用于存储计算的最终结果。

2. **逐元素处理并更新结果**：
   - 对于数组中的每个元素 $A_i$，更新结果使用公式：
    
    $result += (i-1) \times A_i^2 - 2 \times A_i \times sum + sum_{squares}$
     - $(i-1) \times A_i^2$：计算当前元素平方后与之前元素个数的乘积。
     - $-2 \times A_i \times sum$：从平方和中减去当前元素与之前所有元素的两倍乘积。
     - $+sum_{squares}$：加上到目前为止所有元素的平方和。
   - 更新 `sum` 和 `sum_squares` 以包含当前元素。

3. **输出结果**

---

## \[ABC194-E\]Mex最小值

<br>


### 题意

给定一个整数数组$A$，数组长度为$N$，我们需要计算每个长度为$M$的子数组的最小未出现的非负整数（也称为`mex`）。然后，找出这些`mex`值中的最小值。

### 解法

考虑到`mex`的计算需要频繁查询最小的未出现的非负整数，可以使用数据结构如集合（`set`）来高效地维护和更新窗口内元素的出现情况。通过滑动窗口技术，我们可以在移动窗口时逐步更新元素的出现频率，从而快速计算每个窗口的`mex`。

--- 

#### 关键步骤
1. 初始化频率数组`cnt[]`和集合`not_have`。`cnt[]`用于记录窗口内各元素的出现次数，而`not_have`用来维护当前未出现的最小非负整数。初始时，可以把$0$到$max(a_i)+1$都添加到集合中。
2. 滑动窗口：遍历数组，对于每个新元素，增加其频率，若该元素首次出现，则从`not_have`中移除。对于离开窗口的元素，减少其频率，若频率降至零，则将其加回到`not_have`。
3. 每次窗口更新后，从`not_have`中取出最小元素作为当前窗口的`mex`，并更新全局最小的`mex`值。

通过这种方法，每次窗口滑动仅需对数时间更新`not_have`，使得整体算法效率较高，适合处理大规模数据。

---

## 

<br>


### 题意


### 解法

---

## 

<br>


### 题意


### 解法
