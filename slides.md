---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0808 讲题

---

## \[ABC175-A\]雨季

<br>


### 题意

在 AtCoder 镇的连续三天里，用一个长度为 3 的字符串 $S$ 记录天气情况，其中 $S$ 表示晴天，$R$ 表示雨天。要求找出这段时间内连续雨天的最大天数。


### 解法

首先，我们需要读取输入字符串 $S$。接下来，我们需要一个变量来记录当前连续的雨天数，另一个变量来记录最大连续雨天数。

通过遍历字符串 $S$ 的每一个字符，如果当前字符是 $R$，则增加当前连续雨天数，并检查它是否大于最大连续雨天数，如果是则更新最大连续雨天数。如果当前字符不是 $R$，则重置当前连续雨天数为 0。

最后，输出最大连续雨天数。


---

## \[ABC175-B\]制作三角形

<br>


### 题意

我们有 $N$ 根木棍，每根木棍有一个长度。我们需要计算有多少种方法可以选择三根不同长度的木棍，使它们可以组成一个三角形。

### 解法

1. 读取木棍数量 $N$ 和每根木棍的长度。
2. 对木棍的长度进行排序。
3. 使用三重循环枚举所有可能的三元组 $(i, j, k)$，确保 $1 \leq i < j < k \leq N$。
4. 对于每个三元组，检查 $L_i, L_j, L_k$ 是否不同。
5. 检查 $L_i, L_j, L_k$ 是否可以组成三角形，即满足 $L_i + L_j > L_k, L_i + L_k > L_j, L_j + L_k > L_i$。
6. 对于每个满足条件的三元组，计数累加。
7. 输出满足条件的三元组数量。



---

## \[ABC175-C\]行走的高山

<br>


### 题意

有一个数 $X$，对它进行 $K$ 次 $+D$ 或 $-D$ 的操作，求操作后的 $min |X'|$。


### 解法


首先，$X$ 的正负不影响结果，所以我们可以只考虑 $|X|$。

如果 $|X| > D$，那么我们首先应该向原点移动，直到 $|X'| < D$。这时还剩下 $K'$ 次操作，我们应当在原点的左右两侧来回移动。根据 $K'$ 的奇偶判断一下最后在哪一个位置即可。

---

## \[ABC175-D\]移动件

<br>


### 题意

当前位置为i,走一步，所达位置为P[i],此步贡献分数为C[i].给定最多可走的步数k,读者可选择走[1,k]之间的任意步，要求分数最多，输出这个最多的分数值。

### 解法

可以肯定的是，从任意一个位置出发，最后走的点一定会形成一个周期。

首先，计算从每个位置$i$出发，走完一个周期能得到的分数$d[i]$，以及周期内的最大分数$mid[i]$。

枚举每一个起始位置，对k的范围进行分类讨论。

1. 如果不能走完一个周期，则直接计算即可，最大消耗$n$步，$n \times n$满足题目要求。

--- 

2. 如果能走完当前至少一个周期，首先是当前周期内的最大分数$mid[i]$。

2.1 然后看走完后剩余部分，如果剩余0步，也就是恰好能走完多个周期，则最大值可能是前面每个周期都走完$d[i] \times (能走周期数 -1)$，最后一个周期为周期内最大分数$mid[i]$。

2.2 如果剩余部分不能走完一个周期，则前面每个周期还是走完，最后一个周期单独计算即可。






---

##  \[ABC175-E\]拣货

<br>


### 题意

在一个$R$行$C$列的网格上，分布着$K$个物品，每个物品位于特定的单元格并拥有一定价值。Takahashi从$(1,1)$出发，目标是到达$(R,C)$，途中他可以沿两个方向移动，并可以选择捡起他经过的单元格中的物品。每行最多只能捡起三个物品。任务是计算Takahashi能捡起的物品的价值之和的最大可能值。


### 解法

1. 初始化一个动态规划数组`dp[i][j][k]`，其中$i$和$j$表示当前所在的行和列，$k$表示当前行已捡起的物品数（$0$到$3$）。

2. 遍历每个单元格，更新`dp`值，基于从左边或上方来到当前单元格的两种可能，并考虑是否捡起当前单元格的物品。


---

##  \[ABC175-E\]拣货

更新方法：

首先，$dp[i][j][0]$可能是从上一行递推过来，即$dp[i-1][j][0-3]$，也可能是上一列递推过来，即 $dp[i][j-1][0]$ 。

然后，$dp[i][j][1]$可能是从上一行0个物品递推过来，即$dp[i-1][j][0-3]+a[i][j]$，也可能是从上一列0个物品或者1个物品递推过来，即 $dp[i][j-1][0]+a[i][j],dp[i][j-1][1]$两个中的最大值。

$dp[i][j][2]$ 可能由上一列的 $dp[i][j-1][1]+a[i][j]$ 或者 $dp[i][j-1][2]$ 递推过来。

$dp[i][j][3]$ 可能由上一列的 $dp[i][j-1][2]+a[i][j]$ 或者 $dp[i][j-1][3]$ 递推过来。

最后，输出到达 $(R,C)$ 的最大值，即 $dp[R][C][i],i=0,1,2,3$ 中的最大值。

状态压缩：由于每次都仅仅使用了上一行的数据，因此所有的 $i$ 和 $i-1$ 可以换成 $i\%2,(i-1)\%2$ ，定义的时候定义成 $dp[2][3000][4]$。

---

##  最优子矩阵

### 题意

给定一个矩阵，矩阵每个位置有一个数字，找到内部所有数字求和大于0的，面积最大的子矩阵。

### 解法

最简单的方法：直接枚举所有的子矩阵，每个子矩阵求和。

优化1：改用[二维前缀和](https://oi-wiki.org/basic/prefix-sum/#%E4%BA%8C%E7%BB%B4%E5%A4%9A%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C)，不必每次都计算子矩阵的和。

优化2：从最大的面积开始，到面积为1的矩阵开始枚举，找到第一个满足要求的矩阵。该方法只能一定程度上减小时间消耗，并不能降低时间复杂度。

---

优化3：考虑一维数组$a[i]$，$sum[i]$为从左到右累加的和。

对于一个位置$i$，要判断是否存在$a[i]$一直累加到$a[j]$是否大于0，也就是判断是否存在$sum[j]>sum[i]$。

我们从$i$向右遍历，无需遍历到头，定义一个$ma[j]$表示从右向左到$j$的位置，$sum[j]$的最大值，如果遍历到$ma[j]<=sum[i]$，就没有必要继续遍历了，因为右侧所有的$sum[j]$都小于$sum[i]$，因为$ma[j]$是右侧所有的$sum[j]$的最大值。