---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0819 讲题

---

## \[ABC195-A\]健康与死亡

<br>


### 题意

高桥是一位魔术师，他可以使用魔法击败生命值为特定倍数的怪物。具体来说，如果一个怪物的生命值是整数$M$的倍数，则他的魔法能够击败它。现在给定怪物的生命值$H$，需要判断高桥的魔法是否能击败这个怪物。



### 解法

题目的核心在于判断一个整数$H$是否是另一个整数$M$的倍数。这是一个基本的数学问题，可以通过取模运算来解决。如果$H \mod M = 0$，则说明$H$是$M$的倍数；否则不是。

### 关键步骤

1. 读取输入值$M$和$H$。
2. 使用取模运算判断$H$是否是$M$的倍数。
3. 如果$H \mod M = 0$，输出"Yes"表示魔法能击败怪物；否则输出"No"表示不能击败。



---

## \[ABC195-C\]逗号

<br>


### 题意

题目要求计算当从1到给定数字N时，按照英语习惯每三位数字使用一个逗号的格式书写所有整数，总共需要使用多少个逗号。


### 解法

为了计算总逗号数，需要考虑从最小的带逗号的数字1000开始。不同数位级别的数字所具有的逗号数不同。每增加一个级别，数位增加3，逗号数增加1，如从1000（1个逗号）到1000000（2个逗号）。因此，可以根据数字的位数直接计算在该位数范围内所有数字包含的逗号总数。

---

#### 关键步骤

1. **初始化变量**：
   - `total_commas`：用于统计答案。
   - `range_start`：设置为 1000，即从第一个需要添加逗号的数字开始计算。

2. **循环处理各数字范围**：
   - 使用一个循环，从 `1000` 开始，每次范围扩大 1000 倍（即 1000, 1000000, 1000000000 等）。
   - 在每次循环中：
     - 计算当前范围的结束点 `range_end = range_start * 1000 -1`，如从 1000 到 999999。如果 `range_end` 超过了 n，则调整为 n。
     - 每个范围使用的逗号数是 `(range_end - range_start + 1) * (digits / 3)`，其中 `digits / 3` 表示当前数字长度每增加三位逗号数增加1。

3. **输出结果**

---

## \[ABC221-C\]选择乘法

<br>

### 题意

给定一个整数 $N$，任务是将 $N$ 的数字重新排列并分割成两个正整数，目的是使这两个正整数的乘积最大。需要注意的是，分割后的整数不能包含前导零。

### 解法

直接枚举所有的可能。

首先，我们把输入的数字看成一个字符串，首先可以对它进行一个全排列，找出所有的排列的可能。

对于每种排列，我们都可以枚举切断的位置，判断没有前导0，且两个数字都不是0就可以计算两个部分的乘积，最后取一个最大值就可以。

---

## \[ABC195-B\]许多橙子

<br>


### 题意

给定一个范围 $A$ 到 $B$（包含 $A$ 和 $B$），代表橙子的重量范围（单位为克），和一个目标总重量 $W$（单位为千克）。目标是找到可能的最小和最大的橙子数量，使得这些橙子的总重量恰好是 $W$ 千克。如果无法准确达到这个重量，则输出 "UNSATISFIABLE"。


### 解法-简易版

为了确定恰好能使橙子总重量等于 $W$ 千克的最小和最大橙子数量，我们需要考虑以 $A$ 为最小重量和以 $B$ 为最大重量的情况。计算的核心是找到满足条件的橙子数量范围。

#### 关键步骤

1. **橙子数量遍历**：从最小数量$1$开始，遍历到理论上的最大数量$1 \times 10^{10}$，检查对于每个数量 $i$ 是否存在一个情况，使得 $i \times A \leq W \times 1000 \leq i \times B$。
2. **输出结果**：如果在任何数量下都无法精确匹配 $W \times 1000$ 克，则输出 "UNSATISFIABLE"。否则，输出满足条件的最小和最大数量。

---

### 解法-复杂版

本题数据被加强，上面的方法会有几个点过不了。

首先把单位换算一下，$w=w \times 1000$。

先考虑最多，为了达到“最多”，我们考虑尽量多地使用 $a$，但是这里有个问题 —— 我们可能会剩下一部分，即$w\%a$，这部分要分摊到$k = \lfloor \frac{w}{a} \rfloor$ 个橘子上，这 $k$ 个橘子上。

每个橘子最多分配$b-a$克，这些橘子最多可以分配 $k(b-a)$ 克，如果剩下的重量超过了那么多，则无解。

考虑完最多，我们来想一想最少，情况十分类似 —— 考虑使用尽可能多的 $b$，但是同样，我们可能会剩下一些重量。

同样的，设 $l = \lfloor \frac{w}{b} \rfloor$，如果没有余数，显然最少橘子就是 $l$，但是如果有剩下，最少橘子就是 $l+1$。

与最大值不一样的情况是，我们剩下的橘子一定是 $<b$ 的，说明我们新增加的橘子是不会超过上界，但是下界 $a$ 是否能够达到？

或许不能，但是我们可以从重量为 $b$ 的橘子中分一些给它，让它达到下界，并且这种情况一定是可以的。考虑如果$k=l$，此时情况与最小值相同了，因此一定有解。如果$l<k$，由于我们已知$w=k \times a + r$，当$l$小于$k$时，余数一定是能满足大于$a$的，显然是满足题意的。

---

##  \[ABC221-D\]在线游戏

<br>


### 题意

给定一个长度为$2 \times 10^9$的序列，初始全为0。需要进行$n$次操作，每次在一段区间$[l, r]$上加1。对于$1 \leq k \leq n$，最终输出值为$k$的点的个数。

### 解法

本题做法不唯一，使用线段树动态+离散化等方案应该也能过。这里介绍使用差分+离散化解决。

由于操作涉及到对一个非常长的序列进行区间加法，直接模拟会因空间和时间限制而不可行。看到区间加 $1$，考虑差分，将区间修改变为单点修改。

然而，序列的长度达到$2 \times 10^9$，因此需要使用离散化技术来压缩空间。

所以我们开一个 `pair<int,int>` 记录该点的实际位置和差分值。按照实际位置从小到大排序。用 $s$ 记录当前点的真正值，每次将 $s$ 加上差分值来更新当前点真正值。则真正值为 $s$ 的区间为 $p_i \sim p_{i+1}$ 这一段，用 $ans_s$ 加上这一段的长度即可。 最后从 $1$ 到 $n$ 输出 $ans_k$。

---

- `n`: 操作的次数。
- `x`, `y`: 表示对区间 `[x, x+y)` 进行操作。
- `p[]`: 存储每个区间操作的起始点和结束点，使用 `pair<int, int>` 存储位置和差分值。
- `tot`: `p[]` 数组中实际存储的元素个数,即有多少个位置进行了加或者减操作。
- `ans[]`: 存储每个值对应的点的个数。


1. **输入处理**:
   - 读入操作数 `n`。
   - 对于每次操作，读入 `x` 和 `y`，将操作区间 `[x, x+y)` 转化为差分操作，存入 `p[]` 数组。即在 `x` 位置加1，在 `x+y` 位置减1。

2. **离散化处理**:
   - 对 `p[]` 数组按照第一个元素（位置）进行排序。
  
---

3. **差分数组累加**:
   - 遍历排序后的 `p[]` 数组，通过差分值更新当前位置的实际值 `s`。
   - 对于数组中的当前位置 `p[i]`，其影响的区间是 `[p[i].first, p[i+1].first)`，即从当前位置到下一个位置之前的所有点的值都是 `s`。
   - 根据 `s` 的值，将区间长度（`p[i+1].first - p[i].first`）累加到结果数组 `ans[s]` 中。

4. **输出结果**:
   - 从 1 到 n 输出 `ans[]` 数组中的值。


---

## \[ABC221-E\]LEQ

<br>


### 题意

给定一个长度为 $N$ 的整数序列 $A = (A_1, A_2, \dots, A_N)$，需要找出满足以下条件的子序列 $A' = (A'_1, A'_2, \dots, A'_k)$ 的数量，且子序列长度至少为 2：

$A'_1 \leq A'_k$。
即找出所有满足首项小于等于末项的非连续子序列的数量，并对结果取模 $998244353$。

### 解法

固定头$a_i$与固定尾$a_j$，一共会有$2^{j-i-1}$个子序列，因为中间的都只有两种选择：选，或者不选，中间的数一共有$j-i-1$个，因此共有$2^{j-i-1}$次选择。那么我们就可以枚举序列的末端，然后再去枚举序列的头，乘上$2^{len-2}$，公式为

$$
\sum_{j=1}^n \sum_{i=1}^{j-1} 2 ^{j-i-1} (a_i \leq a_j)
$$

---

上述公式实现起来的复杂度为$O(n^2)$,这明显会T.



由于数字值域比较大，因此需要对数据进行离散化，事实上我们只需要知道他们的大小关系，并不关心他们的实际大小，因此，我们可以对原来的数据进行一个排序，将新的数据映射为排序后的下标即可。例如$100,300,200$，我们可以映射为$1,3,2$。

同时，对于每个$j$，我们要计算

$$
\sum_{i=1}^{j-1} 2 ^{j-i-1} (a_i \leq a_j)，
$$
可以把$2^{j-1}$提出来，我们要计算的就是：

$$
2^{j-1} \sum_{i=1}^{j-1} 2^{-i}
$$
因此，我们完全可以在树状数组中保存$2^{-i}$。

---

但是，题目中要求的是对998244353取模运算的结果，

首先，我们需要一个快速幂函数来计算 $2^{j-1}$，因为在每次计算贡献时都需要此值。另外，我们还需要计算 $2^{-i}$，即 $2$ 的负幂次，这可以通过计算 $2$ 的模逆元实现。

使用费马小定理，我们可以得到$2^{-i} \mod p = 2^{p-2} \mod p$,即 $2^{-1} \mod 998244353$ 为 $2^{998244351} \mod 998244353$。

```cpp
ll modInverse(ll base, ll m) {
    return qpow(base, m - 2, m); 
}
```


---

## \[ARC101-E\]树上的彩带

<br>


### 题意

给定一棵$n$个点的树，保证$n$为偶数。将$n$个点分成$\frac{n}{2}$个无序点对。对于每个点对，将树上两点之间的最短路径上的边染色。问有多少种分法使得每条边都被染色。

### 解法


1. **组合计数**：先考虑如何计算一棵树中顶点两两配对的方案数。如果顶点数为偶数，则合法配对方案数是 $(n-1) \times (n-3) \times \ldots \times 1$，记作 $g(n)$。这是因为我们先选择一个顶点与其他 $n-1$ 个点之一配对，然后依次选择剩余的点进行配对。

2. **容斥原理**：接着，通过容斥原理计算每条边至少被一条彩带覆盖的方案数。我们设 $f(S)$ 为集合 $S$ 中的边都未被覆盖时，树中每个连通块内部的配对方案数。可以通过公式 $f(S) = \prod_{i=1}^{|S|+1}g(\text{size}[i])$ 计算，其中 $\text{size}[i]$ 表示连通块的大小。

---

3. **容斥求和**：最后，利用容斥原理，答案即为 $\sum_{S\subseteq E}(-1)^{|S|}f(S)$，即考虑所有边的组合，逐步加减不同组合下的配对方案数。

4. **动态规划优化**：直接枚举 $S$ 会导致时间复杂度过高，因此采用树形动态规划进行优化。设 $dp[x][i]$ 表示在以 $x$ 为根的子树中，有 $i$ 个点未匹配的方案数。通过递归计算 $dp$ 表，最后答案为 $dp[1][0] \times (-1)$。
