---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0812 讲题

---

## \[ABC187-A\]大数字

<br> 


### 题意

给定两个三位数的整数$A$和$B$，需要找出这两个数各自数字之和中的较大者。如果两者相等，则输出$A$的数字之和。


### 解法

1. 计算整数$A$和$B$的数字之和$S(A)$和$S(B)$。这可以通过对每个数进行模$10$和整除$10$的操作循环得到。
2. 比较$S(A)$和$S(B)$，输出较大的那个数的数字之和。如果$S(A) = S(B)$，则输出$S(A)$。

---

## \[ABC186-B\]网格上的块

<br>


### 题意

给定一个由 $H$ 行和 $W$ 列组成的网格，每个方格有一定数量的块。求最少需要移除多少块使所有方格的块数相同。


### 解法

1. 首先，读取整个网格的数据，并找出所有方格中的最小块数。
2. 然后，计算将每个方格的块数降低到最小块数所需移除的块数总和。

---

## \[ABC186-C\]不幸的7

<br>


### 题意

给定一个整数$N$，找出从1到$N$（含）之间既不在十进制表示中包含数字7，也不在八进制表示中包含数字7的整数的数量。

### 解法

1. 对每个整数$i$从1到$N$，检查其十进制和八进制表示是否包含数字7。这可以通过不断除以10或8并检查余数是否为7来实现。

2. 计数所有满足条件的整数，并输出这个数量。


---

## \[ABC186-D\]差异总和

<br>


### 题意

给定一组整数，计算所有可能的整数对之间的绝对差值的总和。

### 解法

简单做法：直接用$n^2$遍历所有的数对。




---

## \[ABC186-D\]差异总和

<br>


1. **排序**：首先将整数数组进行排序。排序后，数组中的每个元素将会与它之后的元素形成一个升序对，这样可以直接计算差值而不需要关心差的正负。

2. **利用前缀和优化差值计算**：通过单次遍历配合前缀和技术计算差值总和。具体步骤如下：
   - 初始化一个变量 `ans` 用于存储总差值和，另一个变量 `sum_prefix` 用于累计到当前遍历位置的所有元素之和。
   - 遍历数组中的每个元素（从第二个元素开始），对于当前元素 `a[j]`，其与之前所有元素的差的总和可以表示为：`a[j]` 乘以其位置索引减 1（即$j-1$，前面有多少个数与它形成对）减去 `sum_prefix`（即与它形成数对的所有元素的总和）,$ans += a[j] \times (j-1) - sum\_prefix$
   - 更新 `sum_prefix` ,加上当前元素 `a[j]` 的值。
   - 这样，每次循环可以在 O(1) 的时间复杂度内计算出当前元素与之前所有元素的差的总和，从而避免了嵌套循环，大大提高了效率。

3. **输出结果**：遍历完成后，`ans` 中存储的就是所求的所有整数对的绝对差值总和，最后输出该值。

---

## \[ABC186-E\]宝座

<br>


### 题意

在围成一圈的$N$把椅子中，其中一把是王座。一个人从王座顺时针数第$S$个位置起始，每次向前移动$K$个位置。问他第一次坐到王座上需要多少次移动，如果无法坐到王座上则返回-1。


### 解法

令 $X$ 为移动次数，$Y$ 为移动圈数，则有：

$$
XK + S = YN
$$

从而我们得到以下方程：

$$
YN - XK = S
$$

这是一个典型的同余方程。这里可以利用扩展欧几里得算法（Extended GCD）先求解得到：


---


### 解方程 $YN - XK = S$

1. **计算 GCD 和基本解**：首先，使用扩展欧几里得算法找到$Y'$ 和$X'$使得
  $$
   Y'N + X'K = \gcd(N, K)
  $$
   这为我们提供了满足最简形式的基本解。

2. **检查$S$是否可行**：如果
  $$
   S \% \gcd(N, K) \neq 0
  $$
   那么没有解，因为$S$不能被$\gcd(N, K)$整除。

3. **调整比例**：如果$S$可以被$\gcd(N, K)$整除，那么将$Y'$和$X'$乘以
  $$
   \frac{S}{\gcd(N, K)}
  $$
   将提供$YN - XK = S$的一个解。

这样，原方程的解就可以通过调整扩展欧几里得算法得到的基本解来找到。


---

## \[ABC186-F\]网格上的车

<br>


### 题意

我们有一个带障碍的网格，网格的起点在$(1,1)$处有一个象棋中的车。需要计算这个车在两步或两步以内能到达多少个方格。


### 解法


1. 维护每一行和每一列的第一个障碍物的位置：
   - `r[i]` 表示第 $i$ 行的第一个障碍物列下标。
   - `c[i]` 表示第 $i$ 列的第一个障碍物行下标。

2. 计算能直接到达的格子数：
   - 令$i$为当前列($1 \leq i \leq r[1]$)，对于每个$i$，车可以直接到达的格子数为 `c[i]-1`。
   - 令$i$为当前行($1 \leq i \leq c[1]$)，对于每个$i$，车可以直接到达的格子数为 `r[i]-1`。

--- 

1. 消除重复统计的格子：
   - 需要从总数中减去重复统计的格子数。
   - 例如，在统计第 $i$ 列时，本来应累加 `c[i]-1`，令$j$为行号($1 \leq j < c[i]$)，重复的格子数是$j$中 `r[j] > i` 的行数，即在计算第$j$行时，会把这个格子再次计算。不重复的格子数即为满足 $r[j] \leq i$ 的行数。


现在的问题就是，已知一个数组$r$，有$i$次询问，每次询问是问这个数组的前$c[i]$项中，大于$i$的有多少个。换句话说，就是找出数组在指定范围内大于特定值的元素数量。

即，每次查询为：对于数组$r$，找到$(j<c[i])$的情况下，满足$r[j]>i$的$j$有多少个。

我们可以换一个角度来看这个问题，原问题可以转换为：已知一个数组$r$，有$i$次询问，每次询问是问数组r中，$r[j]<i$的所有$j$，有多少个在$c[i]$之前，即$j<c[i]$。

这样转换的好处是，原来每次询问的$c[i]$是没有规律的，但是现在询问的是有规律的，每次$i$都比之前大。

因此，我们可以将每个数对，按照$r$的大小从小到大排序，这样，每次询问的时候范围都只会变大不会变小。

---

问题再次转化为，已知一个集合S，这个集合每次都会补充一些元素，请问这个集合中小于$c[i]$的元素有多少个。

这时候就可以使用一个树状数组，在集合中添加一个元素$j$，$sum[j]+=1$，表示$j$在集合里面出现。要计算出现了多少个$j$满足$j<c[i]$，只要计算前$c[i]$项的和即可。

---


1. 快速统计满足条件的行数：
   - 将 $(r[k], k)$ 按照 $r[]$ 从小到大排序。
   - 枚举每列 $i$，使用树状数组存储 $k$ 值，通过查询 `1` 到 `c[i]-1` 的前缀和，快速得到不重复格子的数量。

这种方法通过精细的索引和前缀和的应用，高效地处理了大量数据，避免了直接模拟带来的复杂度问题。
