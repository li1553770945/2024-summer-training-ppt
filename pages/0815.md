---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0815 讲题

---

## \[ABC191-A\]消失的投球

<br> 


### 题意

高桥投球后，球会在一定时间段内不可见。青木只有在球可见时才可能击中球。给出球的速度、不可见的时间段，以及球的目标距离，判断青木是否能击中球。

### 题解

1. **输入解析**：读取球的速度 `V`、球不可见的开始时间 `T`、结束时间 `S` 以及目标距离 `D`。

2. **计算关键时间点的距离**：计算球在 `T` 秒和 `S` 秒时所处的位置，即 `distance_at_T = V * T` 和 `distance_at_S = V * S`。

3. **判断球是否可见**：如果球在距离 `D` 处时的距离不在 `T` 秒到 `S` 秒之间，即 `D < distance_at_T` 或 `D > distance_at_S`，则球是可见的，输出 "Yes"。否则，输出 "No"。


---

## \[ABC193-B\]玩Snuke

<br>

### 题意

高桥想购买一款热门游戏机，每家商店距离高桥所在位置有一定步行时间，并且每家商店的售价和库存数量各不相同。由于游戏机非常抢手，从第0.5分钟开始，每过1分钟各商店的库存都会减少1台。高桥需要找到一个能在他到达时还有库存的商店，并以最少金额购买游戏机。

### 题解

1. **输入数据并初始化**：
   - 读取所有商店的步行时间、售价和库存数据。
   - 初始化一个变量用于记录高桥能购买到游戏机的最低价格。





---

## \[ABC193-B\]玩Snuke

<br>

2. **遍历所有商店**：
   - 对于每家商店，判断高桥到达时库存是否足够（即到达时间小于库存数量）。
   - 由于库存每分钟减少1，实际上的库存就是“初始库存-到达时间”。
   - 如果库存足够，比较当前商店售价与已记录的最低售价，并更新最低售价。
  
3. **输出结果**：
   - 如果找到符合条件的商店，输出最低售价；否则，输出`-1`，表示无法购买。

---

##  \[ABC193-C\]未表达

<br>


### 题意

给定一个整数 $N$，计算在1到$N$的范围内，有多少个整数不能被表示为$a^b$的形式，其中$a$和$b$都是不小于2的整数。

### 题解

1. **初始化集合和遍历计算**：使用一个集合存储所有能够表示为$a^b$的数。首先遍历每个可能的$a$从2开始到$\sqrt{N}$，对每个$a$，遍历可能的$b$从2开始，计算$a^b$，直到结果超过$N$，将这些结果添加到集合中。
2. **计算结果和输出**：计算未被表示为$a^b$的数字数量，即$N$减去集合中元素的数量，并输出这个值。

---

## \[ARC101-C\]蜡烛

<br>


### 题意

给定 $N$ 支蜡烛放置在一条数轴上的不同位置，位置由 $x_1, x_2, ..., x_N$ 表示，并保证 $x_1 < x_2 < ... < x_N$。开始时，所有蜡烛都未点燃。用户初始位于坐标 $0$，需要移动到蜡烛的位置上点燃其中的 $K$ 支。任务是计算点燃这 $K$ 支蜡烛的最短移动时间。

### 解法

点燃的蜡烛一定是一段连续的，因此枚举点燃了哪一段即可。

1. **初始化最小时间**：设定一个很大的数作为初始时间。
2. **遍历所有可能的起点**：从 $1$ 到 $N-K+1$，每次尝试一个新的起点。

--- 

3. **计算每个区间的时间**：
   - 对于每个选定的起点，计算终点为起点加 $K-1$。
   - 考虑两种情况：
     - **跨越原点**：计算两种移动策略的时间，一是先移动到最左侧再移动到最右侧，二是先移动到最右侧再移动到最左侧。
     - **同侧**：直接计算从 $0$ 到最远端的时间。
4. **更新最小时间**：对于每个区间的时间，如果它比当前记录的最小时间小，则更新最小时间。
5. **输出最小时间**：最后输出计算得到的最短时间。

---

## \[ABC191-C\]数字涂鸦

<br>


### 题意

给定一个 $n \times m$ 的网格，每个单元格可以是黑色 '#' 或白色 '.'。网格的边界全是白色。保证所有黑格子连通,所有白格子也连通,统计黑格子组成的多边形有几条边。

### 解法

多边形边数与顶点数相同,只需统计顶点数，对于每个网格点判断其是否为多边形顶点即可。

考虑对于网格中的一个网格点，他周围有4个单元格，可能存在以下几种情况：



---


1. 没有黑色单元格：

![](https://img.peacesheep.xyz/20240814142928.png)

该情况下不是多边形的一个顶点。

---

2. 只有一个黑色单元格
   
![](https://img.peacesheep.xyz/20240814143353.png)

该情况下是多边形的一个顶点。




---
layout: two-cols
---



<template v-slot:default>
3. 有两个黑色单元格

![](https://img.peacesheep.xyz/20240814143435.png)

这种情况不是端点。
 
</template>
<template v-slot:right>

![](https://img.peacesheep.xyz/20240814143450.png)

这种情况不符合题意。

</template>

---

4. 有三个黑色单元格
   
![](https://img.peacesheep.xyz/20240814144110.png)

该情况下是多边形的一个顶点。

---

5. 有四个黑色单元格
   
![](https://img.peacesheep.xyz/20240814144149.png)

该情况下不是多边形的一个顶点。

---

综合上面的分析，我们可以发现，对于四个方格的子矩阵来说，如果有一个单元格是黑色或者有三个单元格是黑色，那么这个子矩阵中间的点就是多边形的一个端点。

因此，我们枚举所有的四个方格的子矩阵，判断如果有一个或者三个黑色方格，那么答案就+1。

---

## \[ABC191-E\]迅速归来

<br>


### 题意

在一个国家有 $N$ 个城镇和 $M$ 条单向道路，每条道路从城镇 $A_i$ 到城镇 $B_i$，需要 $C_i$ 分钟。可能存在某条道路从一个城镇返回到同一城镇（即 $A_i = B_i$）。现在需要判断从每个城镇出发是否存在一条经过一条或多条道路并返回到出发城镇的有效路径，并求出这种路径所需的最短时间。

### 解法

定义$disc[u][v]$为从$u$到$v$的最短路，考虑从每个点$u$出发，如果存在一个环，则必定存在一个$v$，使得$disc[u][v]$不为inf，disc[v][u]不为inf，答案就是$disc[u][v]+disc[v][u]$，需要注意的是，可能存在自环，需要单独判断一下即可。

1. **初始化数据结构：**
   - 定义一个二维数组 $disc$ 用于存储从任意一个城镇出发到其他城镇的最短距离，初始化为无穷大 $inf$。
   - 定义一个一维数组 $dir$ 用于存储从每个城镇直接返回自身（自环）的最短距离，初始化为 $inf$。



---

2. **输入数据并构建图：**
   - 读取 $N$ 和 $M$ 的值，然后读取每条道路的起点 $A_i$、终点 $B_i$ 和权重 $C_i$。
   - 如果 $A_i = B_i$，更新 $dir[A_i]$ 为 $C_i$，即处理自环的情况。
   - 否则，将这条边加入邻接表中。
  
3. **Dijkstra算法求最短路径：**
   - 对于每个节点 $s$，使用 Dijkstra 算法求解从节点 $s$ 到其他所有节点的最短路径，更新 $disc[s][v]$。

4. **计算最短环路时间：**
   - 对于每个节点 $u$，计算从 $u$ 出发并返回的最短有效环路时间。可能的环路时间包括：
     - 直接的自环时间 $dir[u]$。
     - 经过其他节点 $v$ 的环路时间，即 $disc[u][v] + disc[v][u]$。
   - 输出每个节点的最短环路时间。如果不存在有效环路，输出 $-1$。


---

## \[ABC193-F\]斑马条纹


### 题意

给定一个$n \times n$的格子，格子上的每一个位置可能标记为'B'（黑色），'W'（白色）或'?'（未定）。你需要决定每一个'?'应该是'B'还是'W'，以使得相邻的黑色格子和白色格子之间的边的数量最大。

### 解法

这是一个求解网络流问题的题目，目标是找到一个图中的最大流量。

你本题设置中，目的是最大化黑白相邻方格对的数量。这可以被视为寻找一个网络中的最大流，其中：

- 网络的每个节点代表一个方格。
- 源点（source）连接到所有默认为黑色的方格，汇点（sink）连接到所有默认为白色的方格。
- 相邻的方格之间有容量为1的边，表示如果这两个方格被涂成不同的颜色，它们可以贡献一个单位的“流量”，也就是一个黑白对。
- 你的目标是确定未确定色彩的方格('?'方格)的最优色彩配置，以便从源点到汇点的流量（即黑白相邻方格对）最大化。

---

#### 网络流的概念引入
- **源点（Source, S）**和**汇点（Sink, T）**是网络流算法中两个特殊的点，所有流量从源点出发并向汇点流动。
- 在这个问题中，源点代表选择"B"（黑色），汇点代表选择"W"（白色）。

#### 构建网络
- 每个网格点$(i, j)$都被视为一个节点。
- 对于格子中的每一个'B'字符，设置一条从源点到该节点的边，容量为无限大，表示该格子被确定为黑色。
- 对于格子中的每一个'W'字符，设置一条从该节点到汇点的边，容量为无限大，表示该格子被确定为白色。

---

#### 处理'?'未确定的情况
- 对于每一个标记为'?'的格子，同时从源点到该格子和从该格子到汇点各引入一条边。这两条边的容量可以设置为一个较大的固定值（例如网格中可能的最大边数），这样就允许该格子在后续的流量调整中自由地变为黑色或白色。

#### 连接网格内的相邻节点
- 对于网格中任意相邻的两个格子，例如$(i, j)$和$(i, j+1)$，添加两条边，一条从$(i, j)$到$(i, j+1)$，另一条从$(i, j+1)$到$(i, j)$，每条边的容量设为1。这表示这两个相邻格子在涂色后若为不同颜色，可以通过这条边“传递”一个单位的流量，即计算为一个黑白相邻的配对。
  
---

### 流量模拟的含义

- **流量的最大化**：在网络流中，我们寻求从源点到汇点的最大流量。在这个问题中，最大流量代表了最大可能的相邻黑白格子对（即斑马条纹数）。流量在网络中的流动模拟了在决定每个格子颜色时对最终配对数的贡献。
- **流量通过边的含义**：如果某个从$(i, j)$到$(i, j+1)$的边传递了流量，这意味着这两个格子被涂成了不同的颜色，为总的斑马条纹数做出了贡献。

### 总结

将这个涂色问题转换成网络流问题的核心在于把每一个涂色决策模拟为流量的决策，其中网络流的最大流计算反映了最优的涂色方式。通过这种方式，可以有效地利用已有的网络流算法（如Dinic算法）来找到问题的最优解。这种转换不仅提供了一种解决复杂问题的方法，而且还利用了计算机科学中的经典算法来解决看似与之不相关的问题。

---

1. **输入和初始化**：首先读取$n$，接着输入$n \times n$的网格状态。进行初始化，设置网络流的源点和汇点。

2. **图的构建**：
   - 对于每个已确定为'B'或'W'的格子，如果坐标之和为奇数，将它们的颜色反转，以保持图的一致性。
   - 对于每一个格子，根据其位置和状态向网络流图中添加边。如果格子是'B'，则从源点向该格子添加边；如果是'W'，则从该格子向汇点添加边。
   - 对于每一对相邻的格子，添加两条边，表示这两个格子之间可以互相流动（但流量有限制为1），以确保可以统计不同颜色间的边。


---

3. **最大流算法**：
   - 使用Dinic算法来计算从源点到汇点的最大流。Dinic算法通过多次执行BFS来构建分层图，然后用DFS寻找增广路径，从而逐步增加流量。
   - 最终的流量就是最大的黑白边数，用全部可能的边数减去这个值得到结果。

4. **输出结果**：最后，输出通过Dinic算法得到的最大流量值，即为解答。

这种方法结合了网络流技术来处理选择最优方案的问题，非常适合处理涉及大量选择和约束的优化问题。


