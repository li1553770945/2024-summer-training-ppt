---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0813 讲题

---

## \[ABC190-A\]非常非常原始的游戏

<br>


### 题意

高桥和青木进行一个交替吃糖果的游戏，他们分别有一定数量的糖果。游戏由一个人根据给定条件开始，每人每次只能吃一颗糖果，无糖果可吃的人输掉游戏。

### 解法

1. 根据开始者的标志`C`判断谁先开始。如果`C=0`，高桥先开始；如果`C=1`，青木先开始。
2. 比较高桥和青木各自的糖果数，根据谁的糖果多，谁可以持续操作到最后，因此糖果多的人将会赢得游戏。如果相等，则先开始的人输。

---

## \[ABC190-B\]魔法3

<br>


### 题意

魔术师Takahashi正在与怪物战斗，他有多种咒语可用。每种咒语有固定的施放时间和威力。怪物可以避免受到施放时间过长或威力不足的咒语的伤害。判断是否存在至少一种咒语可以对怪物造成伤害。

### 解法

1. 遍历所有咒语，检查每个咒语的施放时间是否小于怪物的防御时间上限，并且威力是否大于怪物的防御威力下限。
2. 如果存在至少一个满足条件的咒语，输出"Yes"，否则输出"No"。


---

## \[ABC190-C\]碗和盘子

<br>


### 题意

有N个编号的盘子和M个条件，每个条件需要特定两个盘子上都有球才满足。K个人各自可以选择在两个不同的盘子中的一个上放球。需要计算出在所有可能的放球方式中，最多能满足多少个条件。

### 解法

1. 使用深度优先搜索（DFS）遍历每个人的放球选择，每个人都有两种选择，即放球在`C_i`或`D_i`盘子上。
2. 对于每种放球组合，计算满足的条件数：遍历所有条件，检查对应的两个盘子是否都有球。
3. 记录并更新能满足的最大条件数。


---

## \[ABC190-D\]楼梯序列

<br>


### 题意

有多少个和为$N$、公差为$1$的等差数列？
$1 \leq N \leq 10^{12}$

### 解法

我们设和为 $N$，公差为 1 的等差数列为首项为$a$，尾项为$b$，则

$\frac{(a+b)(b-a+1)}{2} = N$

$(a+b)(b-a+1) = 2N$

所以，我们求 $2N$ 的奇偶性不同的因子对数即可。

这里注意，题目里的等差数列是可以有负数的，对于我们找到的每个数列，都可以左边补上一个以0对称的数列，所以最终结果要乘 $2$。

代码总时间复杂度为 $\mathcal{O}(\sqrt{n})$。需要注意使用`long long`类型。


---

## \[ABC190-E\]魔法饰品

<br>

### 解法

其实将题目转化一下就是：将所给的关系建边，然后在图中找到一条最短路径使得能包含所需所有点。

1. 首先我们需要求出必须放置的点之间两两的最短路径。

因为k很小，所以我们可以进行$k$次bfs，求出两点间的最短距离。

2. 然后就是一个状压dp的问题了。设`dp[i][j]`表示状态 为 `i` 最后到达的点为 `j` 的最小路径。状态 `i` 变为二进制，第 `i` 位为1表示 `c[i]` 已经经过。那么可以推出转移方程:

```cpp
dp[next_i][next_j]=min(dp[next_i][next_j],dp[i][j]+dis[j][next_j])
```

最后枚举最后到达的点取min即可。

---

## 

<br>


### 题意

给定一个序列 $A = [a_0, a_1, a_2, \dots, a_{N-1}]$，它是 $0, 1, 2, \dots, N-1$ 的一个排列。对于每个 $k = 0, 1, 2, \dots, N-1$，找到序列 $B = [b_0, b_1, b_2, \dots, b_{N-1}]$ 的逆序数，其中 $b_i = a_{(i+k) \mod N}$。逆序数是序列中满足 $i < j$ 且 $b_i > b_j$ 的索引对 $(i, j)$ 的数量。


### 解法


1. 先通过归并排序求出原序列的逆序对。

2. 然后每一次把序列的第一个数轮换到序列末尾，看逆序对数是多少。
   
我们注意到当把 $K$从序列开头移动到序列结尾时，减少了 $K-1$ 个逆序对，同时新增了 $N-K$ 个逆序对，因此变化量为 $N+1-2K$。这样我们就可以逐个求出所有序列的逆序数了。
