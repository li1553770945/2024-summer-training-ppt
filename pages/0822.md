---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0822 讲题

---

## \[ABC200-A\]Century

<br>


### 题意

给定一个年份 $N$，要求判断这个年份属于哪个世纪。一个世纪是100年的时间段，例如1世纪是从1年到100年，2世纪是从101年到200年，以此类推。你需要输出对应的世纪数。

### 题解


为了计算年份 $N$ 所在的世纪，可以考虑将年份 $N$ 除以100。如果年份整除100，那么它刚好是这个世纪的最后一年，否则就需要再加一个世纪。换句话说，我们要考虑年份 $N$ 上取整后除以100的结果，这样可以确保正确计算世纪。


---

## \[ABC200-B\]第200次ABC-200

<br>


### 题意

给定一个整数$N$，需要对其执行$K$次操作，每次操作根据$N$的不同情况执行不同的步骤。如果$N$是$200$的倍数，将其除以$200$；否则，将$N$视为字符串并在其末尾添加$200$。最终输出经过$K$次操作后的结果。


### 解法

这个问题的核心是根据$N$的当前状态来决定下一步操作。由于$N$每次要么被除以$200$，要么变成一个新的字符串并转换成整数，因此问题的关键在于正确地模拟这个过程，并确保每次操作后，$N$的值是符合题目要求的。整个操作最多只需要执行$20$次，所以直接按步骤模拟整个过程是可以接受的。

### 关键步骤
1. **判断并执行操作**：对于每一次操作，首先检查$N$是否是$200$的倍数。如果是，将$N$除以$200$；否则，将$N$转换为字符串形式，并在其后追加字符串`"200"`，然后将该字符串重新转换为整数。
2. **循环执行**：将上述操作循环执行$K$次，最终得到结果。

---

## \[ABC200-C\]Ringo的最爱数字2

<br>


### 题意

给定一个包含 $N$ 个正整数的序列 $A$，要求找出满足 $1 \leq i < j \leq N$ 且 $A_i - A_j$ 是 200 的倍数的整数对 $(i, j)$ 的数量。


### 解法

由于本题$N$比较大，不能直接用两重循环模拟。

我们可以将问题转化为找到两个数的余数相等的情况，因为两个数的差 $A_i - A_j$ 如果是 200 的倍数，那么这两个数对 200 取模后的余数必须相等。因此，问题可以简化为统计每个余数的出现次数，计算满足条件的整数对数目。

---

### 关键步骤
1. **余数计算与统计**：对于序列中的每个数 $A_i$，计算其对 200 取模后的余数，并记录这些余数的出现次数。
   
2. **整数对计数**：对于每一个新遇到的数 $A_i$，检查之前是否有相同余数的数存在。如果存在，则这些数与当前数 $A_i$ 组成的所有整数对 $(i, j)$ 都满足条件，将这些对数累加到结果中。

3. **输出结果**：最后输出累加的结果，即满足条件的整数对数量。

---

## \[ABC201-D\]游戏在摩摩天世界

<br>


### 题意

给定一个 $H \times W$ 的网格，其中每个格子是蓝色或红色。高桥和青木从左上角开始轮流移动棋子，可以向右或向下移动一格，棋子在蓝色格子上得1分，在红色格子上扣1分。当棋子无法继续移动时，游戏结束。两人都采用最优策略，问最终结果是高桥胜、青木胜，还是平局。



### 解法

这个问题的本质是一个博弈论问题。两名玩家都想使自己得分最高，并使对方得分最少。由于两名玩家轮流行动，并且每个格子的得分是固定的，可以通过动态规划自底向上地求解。我们从棋盘的右下角倒推到左上角，计算每个格子的最优得分策略。

---

定义`dp[i][j]` 表示从格子 $(i, j)$ 开始，到达终点 $(H, W)$ 时，该位置的玩家在最优策略下与对手的分数差值：

+ 如果 `dp[i][j]` 是正数，意味着从位置 $(i, j)$ 开始移动，当前玩家可以在最优策略下获得的分数将比对手多 `dp[i][j]` 分。
+ 如果 `dp[i][j]` 是负数，意味着从位置 $(i, j)$ 开始移动，当前玩家在最优策略下会比对手少 `dp[i][j]` 分。
+ 如果 `dp[i][j]` 等于 0，则表示从这个位置开始，两名玩家在最优策略下的得分是相等的。
  

---

#### dp方向

考虑正向dp，从$(1,1)$开始，`dp[i][j]`可以由`dp[i][j-1],dp[i-1],[j]`递推过来，但这种方法仅适合单人问题，每次只能保证自己到达当前位置的时候得到了一个较大的分数。

实际上，我们每一步的选择都会受到后续格子的情况影响。如果我们提前做出决策，只能得到一个局部最优，无法得到全局最优。比如，高桥在某个位置上可能选择向下移动获得最大分数，但之后的局面可能让青木得到了更高的分数，从而未能实现最优解。

换句话说，如果我们要计算$(i,j)$位置，当前玩家向右移动的得分，需要先知道右边和下边对手玩家能获得的最大分数。

因此，本题需使用反向dp，从右下角 $(H, W)$ 开始推进。这样，我们在计算当前位置 $(i, j)$ 的最优策略时，已经知道了下一步可能到达的所有格子的最优结果。这意味着，当前玩家可以基于后续格子的已知结果来选择移动方向，使得他能够得到最优分数或尽量减少对方得分。

---

#### 状态转移

如果当前玩家选择向右移动到 $(i, j+1)$，之后的局面由对手来操作，并且对手也会采取最优策略，那么对手玩家在$(i,j+1)$的得分是`dp[i][j+1]`。因此当前玩家的得分是 `-dp[i][j+1]`，因为当前玩家要对抗对手的最优策略。所以取负数。另外，移动到格子 $(i, j+1)$ 时，如果该格子是蓝色（+），当前玩家得 1 分，如果是红色（-），当前玩家扣 1 分。所以，向右移动可以得到的分数为 `-dp[i][j+1] + a[i][j+1]`。

如果当前玩家选择向下移动到 $(i+1, j)$，情况与右移类似，这条路径的得分为 `-dp[i+1][j] + a[i+1][j]`。

---



1. **初始化和状态表示**：
   - 如果棋子位于终点 $(H, W)$，则 $dp[H][W] = 0$，因为游戏在此结束。

2. **状态转移**：
   - 从右下角倒推至左上角。
   - 若当前玩家在 $(i, j)$，他有两种选择：向右或向下移动。
   - 若移动到 $(i+1, j)$ 或 $(i, j+1)$，考虑对方会采取最优策略反制当前玩家。因此，$dp[i][j]$ 的更新公式为：$dp[i][j] = \max(-dp[i+1][j] + a[i+1][j], -dp[i][j+1] + a[i][j+1])$
   

3. **结果判断**：
   - 最终比较 $dp[1][1]$ 的值：
     - 如果 $dp[1][1] > 0$，则高桥胜；
     - 如果 $dp[1][1] < 0$，则青木胜；
     - 否则，平局。

--- 

## [ABC202-E]统计后代节点数

<br>

## 题意

给出一个 $n$ 个点的有根树，节点编号为 $1, 2, \dots, n$，树根为 $1$，第 $i$（$2 \leq i \leq n$）号节点的父亲是 $p_i$。

给出 $q$ 个查询，第 $i$ 个查询包含 $a_i, b_i$，计算满足以下条件的点 $u$ 的个数：

+ $a_i$ 位于 $u$ 到 $1$ 的最短路径上（端点也算）；
+ $u$ 到根上的路径恰好有 $b_i$ 条边。

题意翻译：

+ u在$a_i$的子树上
+ u的深度为$b_i$

综合两个条件：以$a_i$为根节点的子树中，深度为$b_i$(假设根节点深度为0)的节点有多少个。

---

### 时间戳

节点在dfs被遍历到的开始以及结束时间，可以理解为，每个节点有两个属性 $Tin_i, Tout_i$。

对于一个节点 $u$ 及其任意一个儿子 $v$，有 $Tin_u \leq Tin_v, Tout_u \geq Tout_v$。也就是说，晚辈 $[Tin_i, Tout_i]$ 的区间包含于祖先的区间内。

### 计算方法

在 DFS 一棵树的过程中，维护一个全局的时间戳 clock，每访问一个新的节点，就将 clock +1。同时，记录进入节点 x 时的时间戳 `in[x]=clock`，和离开（递归结束）这个节点时的时间戳 `out[x]=clock`。

在本题中，除了计算时间戳之外，我们还使用一个vector，记录每一层的时间戳$in$。



```cpp {all|3}
void dfs(int u, int depth) {
    Tin[u] = timer++;
    D[depth].push_back(Tin[u]);  // 记录同一层的点
    for (int i = 0; i < e[u].size(); i++) {
        dfs(e[u][i], depth + 1);
    }
    Tout[u] = timer++;
    
}
```

---


由于我们在 DFS 时将同一层的点的时间戳存入了 vector，所以只需要查找同一层中，$a_i$的孩子，也就是满足 $Tin[a_i] \leq Tin[u] \leq Tout[u] \leq Tout[a_i]$ 的点，当然，我们可以只记录每一层时间戳$Tin$，找到$Tin[a_i] \leq Tin[u]  \leq Tout[a_i]$ 的点即可。

因为 DFS 使得 vector 中的数是有序的，所以可以使用二分搜索进行查找。时间复杂度为$O(\log n)$，总时间复杂度为$O(q \times \log n)$

---

## \[ABC200-E\]PatisserieABC2

<br>


### 题意


构造$N^3(N \leq 10^6)$个三元组$(i,j,k)$从左到右排列,$1 \leq i,j,k \leq N$。排列规则如下：

+ 按照$sum=i+j+k$的和，升序排列
+ 如果$sum$相等，那么$i$小的放在左边
+ 如果$sum$和$i$都相等，那么$j$小的放在左边
  
请找到第$K$个三元组。

---

### 暴力

显然，可以直接三重循环枚举$i,j,k$的全排列，时间复杂度为$n^3$。


### 优化方法

本题$s$为排序第一关键字，首先易得 $i,j,k$ 不同时 $s$ 可能相同，所以一个 $s$ 对应一段区间，$i,j$ 同理，也就是确定了$s,i$，也对应一段区间，只有，$s,i,j$ 都确定了，$k$ 就确定了。

首先，我们需要枚举$s$，对于每个$s$，我们需要求出它对应的那一段有多长，也就是他能对应多少个不同的$i,j,k$。

对于一个 $s$，我们把它看成 $s$ 个 $1$ 相加，利用隔板法，我们用两个隔板将 $s$ 分成 $3$ 部分，分别表示 $i,j,k$。因为有 $s$ 个 $1$，所以有 $s-1$ 个间隔，所以第一个隔板有 $s-1$ 个位置。
因为插入隔板后会减少一个间隔，所以第二个隔板有 $s-2$ 个位置。

这时我们注意到：设一隔板位置为 $i$，二隔板位置为 $j$，还有一种情况是一隔板位置为 $j$，二隔板位置为 $i$，这本应属于同一种情况，而我们算了两遍，所以我们再除以 $2$ 就可以了。

即对于每个$s$，求和等于$s$的三元组的数量为$f(s) = \frac{(s-1) \times (s-2)}{2}$。

---



但是我们发现，$i,j,k$ 的取值范围只有 $1\sim N$，任意一值大于 $N$ 都不能取，此时我们使用容斥原理。

我们已经算出所有方案数（简称原方案），只要减去有至少一个值大于 $N$ 的方案数就好了。



我们设 $i$ 大于 $N$，我们可以把前面$n$个数字看成是一个整体，这个时候总的数量就是$s-n+1$，再利用隔板法求出方案数，就是 $f(s - n)$。

当然，$j,k$大于$n$也是同样的道理，因此需要再这个基础上再乘以$3$，即$3 \times f(s - n)$。

此时我们的公式变为$f(s) - 3 \times f(s - n)$。

---

我们又可以把大于 $N$ 的方案分成 $3$ 类：刚刚计算的一个值大于 $N$（简称一方案），两个值大于 $N$（简称二方案），三个值大于 $N$（简称三方案）。

我们易知一方案中包含了二方案和三方案，二方案中也包含了三方案，所以我们要求出原方案，减一方案，加二方案，减三方案的数量。


对于二方案，可能是$i,j$或者$j,k$，或者$i,k$大于$N$，就是 $3 \times f(s - n \times 2)$。对于三方案，由于不需要再分哪个大于$N$，就是 $f(s - n \times 3)$，不需要再乘以3。


综上：设 $t$ 为$s$对应的合法$i,j,k$三元组数量，则 $t = f(s) - 3 \times f(s - n) + 3 \times f(s - n \times 2) - f(s - n \times 3)$。

当然，对于本题来说，$s \leq 3 \times N$ ， 因此最后一项可有可无。

所以我们枚举$s$时只要算出每个 $t$，若 $t<K$，则使 $K = K-t$，只要有一次 $t\leq K$，就找到了我们想要的 $s$ 了。


---

对于每个$s$，我们枚举$i$从$1$到$N$,然后计算每个$i$对应的那一段的长度。对于一个$i$，我们只要计算有多少个$j$即可，因为$i,j$确定的情况下$k$只有一个。

由于$1 \leq j \leq N$,$1 \leq s-i-j \leq N$，因此$\max(s - i - n, 1) \leq j \leq \min(s - i - 1, n)$。

显然$i$对应的长度就是$max_j - min_j + 1$。对于每个$i$,我们同样找出这一段的长度为$t$，则每次$K=K-t$当我们找到一个对应的$i$，使得如果$i+1$会使得$k<0$的时候，也就是$K$这个数字是出现在当前$i$对应的那一段的时候，直接输出这一段数字中的第$k$个就好了。



---

## \[ARC105-E\]保持图不连通

<br>


### 题意

有一张 $n$ 个点 $m$ 条边的无向图，两个人轮流操作，向图中加一条边，每次操作后需要满足下面两个条件：

+ 节点 $1$ 和节点 $n$ 不连通。
+ 没有重边和自环。

谁不能操作就输了，问谁能赢。


### 解法

现最后一定是两个完全图，这两个完全图分别包含节点$1$和节点$n$，且这两个图不联通。

考虑表示出这两个人一共加了多少边：

构成完全图的边数-一开始有的边数-使得两个图联通的边的数量。

---

考虑$x$ 表示点 $1$ 最后所在连通块的大小。

那么使得两个图联通的边一共有$x \times (n-x)$条。因此，两个人能加的边最多是$t = \frac{n(n-1)}{2} - m - x(n-x)$。

由于是判断先手还是后手必胜，所以只需看$t$对 $2$ 的余数，于是对 $n$ 的奇偶进行分讨。

当 $n$ 为奇数时，此时 $x(n-x)$ 一定是偶数，这时只需要对 $\frac{n(n-1)}{2} - m$ 进行讨论。

当 $n$ 为偶数时：对 $1$，$n$ 初始时所在的连通块大小进行讨论，分别记为 $a$，$b$。

当 $a$，$b$ 奇偶性相同时，除了这两个连通块之外，连通块大小为奇数的连通块个数一定为偶数，这时先后手不管怎样都无法改变局势，因为可以通过模仿对方的行动进行抵消。假设一开始$a,b$为奇数，第一个人想要把$a$变成偶数，那么第二个人一定可以在找到一个奇数节点的连通块，把$a$变回奇数，固此时直接看$a$的奇偶性，就是最终$x$的奇偶性。

当 $a$，$b$ 奇偶性不同时，显然先手可以选择变为 $a$ $b$ 奇偶性相同的情况，就变成了第一种情况，故此时先手必胜。
