---
# You can also start simply with 'default'
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
# some information about your slides (markdown enabled)
title: "讲题"
# apply unocss classes to the current slide
class: text-center

# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: slide-left
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# 0816 讲题

---

## \[ABC194-A\]我尖叫

<br>


### 题意

在日本，冰淇淋类产品根据乳固体和乳脂的含量分为四种：冰淇淋、冰奶、乳冰和调味冰。根据乳固体总含量和乳脂含量的不同标准，每种产品有明确的定义。输入给定的是非脂乳固体和乳脂的百分比，需要判断该产品属于哪一类。

### 题解

1. **计算总乳固体含量**：首先计算总乳固体含量，这是非脂乳固体和乳脂含量的总和，即$total\_milk\_solid = A + B$。
2. **分类判断**：
   - **冰淇淋**：如果总乳固体含量不小于$15\%$且乳脂含量不小于$8\%$，则产品为冰淇淋。
   - **冰奶**：如果不符合冰淇淋的条件，但总乳固体含量不小于$10\%$且乳脂含量不小于$3\%$，则产品为冰奶。
   - **乳冰**：如果不符合以上两者的条件，但总乳固体含量不小于$3\%$，则产品为乳冰。
   - **调味冰**：如果以上条件都不满足，则产品为调味冰。
3. **输出相应的分类编号**：根据上述条件判断，输出对应的分类编号。


---

## \[ABC194-B\]工作分配

<br>


### 题意

你的公司有$N$名员工，编号从$1$到$N$。有两个工作任务，分别是工作A和工作B，需要分配给这些员工完成。每个员工完成工作A和工作B所需的时间分别是$A_i$分钟和$B_i$分钟。你可以将两个工作分配给同一个员工，也可以分配给两个不同的员工。目标是找到完成这两项工作的最短时间。

### 解法

1. **数据读取与初始化**：读取员工数量$N$和每个员工完成两项工作所需的时间，存储为两个数组`a`和`b`，每个数组包含时间和员工索引。
2. **排序**：对两个数组进行升序排序，以便快速访问完成每项工作最快的员工。
   
---

3. **最优分配策略**：
   - 如果完成工作A和B最快的是同一员工，比较：
     - 该员工同时完成两项任务的总时间$a[0].first + b[0].first$。
     - 分配工作A给最快员工，工作B给次快员工的时间$\max(b[1].first, a[0].first)$。
     - 分配工作B给最快员工，工作A给次快员工的时间$\max(a[1].first, b[0].first)$。
     - 选择上述时间中的最小值作为结果。
   - 如果不是同一个员工，选择两项工作分别由不同员工完成所需的最大时间$\max(a[0].first, b[0].first)$。
4. **输出结果**：输出计算得到的最短完成时间。
   
由于$N$的范围很小只有一千，也可以直接枚举。

---

##  \[ABC194-C\]平方误差

<br>


### 题意

给定一个长度为 $N$ 的整数数组 $A$，求每对元素 $A_i$ 和 $A_j$（其中 $i > j$）之间平方差的总和。


### 解法

为了避免 $O(N^2)$ 的时间复杂度，我们可以通过数学变形和累积总和的方式来优化计算。主要思想是预先计算和存储所有先前元素的累加和与平方和，利用这些累积值来快速计算每个新元素与所有先前元素的平方差。

考虑到平方差的定义：

$(A_i - A_j)^2 = A_i^2 - 2A_iA_j + A_j^2$

对于每个 $i$，要计算其与前 $i-1$ 个元素的平方差之和，可以重写为：

$\sum_{j=1}^{i-1}(A_i - A_j)^2 = \sum_{j=1}^{i-1}(A_i^2 - 2A_iA_j + A_j^2)$ 

--- 

这可以进一步简化并分开计算为三部分：
1. $A_i^2$ 乘以 $(i-1)$（因为每个 $A_j$ 都会贡献一个 $A_i^2$）
2. $-2A_i$ 乘以前 $i-1$ 个元素的和
3. 前 $i-1$ 个元素的平方和

即： $A_i^2 \times (i-1) - 2A_i \times \sum_{j=1}^{i-1}  A_j + \sum_{j=1}^{i-1} A_j^2$

我们可以维护 `sum` 和 `sum_squares` 两个累积值。通过预存这些值，我们可以将每次的计算降低到 $O(1)$，从而整体上将算法的时间复杂度降低到 $O(N)$。

---

1. **初始化变量**：
   - `sum`：用于累加前面所有元素的和。
   - `sum_squares`：用于累加前面所有元素的平方和。
   - `result`：用于存储计算的最终结果。

2. **逐元素处理并更新结果**：
   - 对于数组中的每个元素 $A_i$，更新结果使用公式：
    
    $result += (i-1) \times A_i^2 - 2 \times A_i \times sum + sum_{squares}$
     - $(i-1) \times A_i^2$：计算当前元素平方后与之前元素个数的乘积。
     - $-2 \times A_i \times sum$：从平方和中减去当前元素与之前所有元素的两倍乘积。
     - $+sum_{squares}$：加上到目前为止所有元素的平方和。
   - 更新 `sum` 和 `sum_squares` 以包含当前元素。

3. **输出结果**

---

## \[ABC196-D\]Hanjo

<br>

## 题意

给定一个大小为 $H \times W$ 的矩形房间，我们需要使用 $A$ 个 $2 \times 1$ 米的矩形榻榻米垫和 $B$ 个 $1 \times 1$ 米的方形榻榻米垫来完全覆盖整个房间。矩形榻榻米垫可以横向或纵向放置。题目保证 $2A + B = HW$，即榻榻米垫的总面积与房间面积相等。需要计算所有可能的覆盖方法数量，其中不同方向的放置被视为不同的方法。

## 解法

### 题解思路

这是一个组合填充问题，采用深度优先搜索（DFS）策略来尝试所有可能的榻榻米垫摆放方法。通过递归方式尝试在每个空单元格放置 $2 \times 1$ 或 $1 \times 1$ 榻榻米垫，并适当地考虑每个榻榻米垫的方向。

--- 

### 关键步骤

1. **初始化状态数组**: 使用布尔数组 `have` 标记每个单元格是否已被覆盖。
2. **递归尝试摆放**:
   - 递归遍历每个位置，尝试放置榻榻米垫。
   - 对于 $2 \times 1$ 榻榻米垫，尝试横向和纵向摆放。
   - 对于 $1 \times 1$ 榻榻米垫，只需放置在当前位置。
   - 确保不越界且不重叠。
3. **记录和输出所有可能的覆盖方法数量**。


---

## \[ABC194-E\]Mex最小值

<br>


### 题意

给定一个整数数组$A$，数组长度为$N$，我们需要计算每个长度为$M$的子数组的最小未出现的非负整数（也称为`mex`）。然后，找出这些`mex`值中的最小值。

### 解法

考虑到`mex`的计算需要频繁查询最小的未出现的非负整数，可以使用数据结构如集合（`set`）来高效地维护和更新窗口内元素的出现情况。通过滑动窗口技术，我们可以在移动窗口时逐步更新元素的出现频率，从而快速计算每个窗口的`mex`。

--- 

#### 关键步骤
1. 初始化频率数组`cnt[]`和集合`not_have`。`cnt[]`用于记录窗口内各元素的出现次数，而`not_have`用来维护当前未出现的最小非负整数。初始时，可以把$0$到$max(a_i)+1$都添加到集合中。
2. 滑动窗口：遍历数组，对于每个新元素，增加其频率，若该元素首次出现，则从`not_have`中移除。对于离开窗口的元素，减少其频率，若频率降至零，则将其加回到`not_have`。
3. 每次窗口更新后，从`not_have`中取出最小元素作为当前窗口的`mex`，并更新全局最小的`mex`值。

通过这种方法，每次窗口滑动仅需对数时间更新`not_have`，使得整体算法效率较高，适合处理大规模数据。

---

##  \[ABC191-F\]GCD或MIN

<br>


### 题意

在黑板上写着 $N$ 个整数。你将进行 $N-1$ 次操作，每次操作选择黑板上的两个数 $x$ 和 $y$，擦掉它们，并在黑板上写下 $\gcd(x, y)$ 或 $\min(x, y)$。操作结束后，黑板上将只剩下一个整数。求出这个剩余数的有多少种可能。


### 解法

1. **操作简化**：
    - 只考虑第一个操作，每次都选择「删除 $x, y$ 加入 $gcd(x, y)$」，最终结果显然是所有数的 $gcd$。

2. **弱化版问题**： 
    - 如果选择「删除 $x, y$ 加入 $min(x, y)$」，相当于删除$x,y$中较大的一个序列中的最大值。
    - 我们把问题简化，允许「删除 $x, y$ 加入 $gcd(x, y)$」或「删除 $x$」，那么可以从序列中任意选择一些数，计算其 $gcd$ 作为最终结果，未选择的数可以删除。
    - 现在问题转化为，给定一个集合，求所有子集的$gcd$一共有多少种可能。

---

3. **最小值约束**：
    - 考虑取最小值与删除的区别：删除可以把序列中的最小值删除，但是取最小值不可以。只要不是$a_{min}$，那么我们可以让他和$a_{min}$进行取最小值操作，就相当于删除这个值。
    - 显然，任意一个数字和$a_{min}$取gcd，结果一定小于或者等于$a_{min}$。
    - 在问题转化为，给定一个集合，求所有子集的$gcd$小于等于$a_{min}$一共有多少种可能。

4. **枚举合法的 $k$**：
    - 直接求所有子集显然会超时，我们可以反向思考，枚举能成为最终结果的$k$，然后再判断是否真的能成为最终结果。
    - 假设某个数 $k$ 可以成为最终答案，那么$a$序列中，$k$的倍数 $\{a_{p_1}, a_{p_2}, \dots, a_{p_n}\}$ 的 $gcd$ 必须等于 $k$。因此，我们可以通过枚举 $a_i$ 的因数 $t$ 来判断是否存在这样的 $k$，并记录这些 $k$ 的个数。

---

5. **具体实现**：
    - 用一个`map`映射到一个`vector`,$map[k]={a_{p_1}, a_{p_2}, \dots, a_{p_n}}$，表示原来数组中$k$的倍数的集合为$\{a_{p_1}, a_{p_2}, \dots, a_{p_n}\}$。
    - 每输入一个数字，就找到他的所有因子，使用`map`将它加到对应因子的vector中。
    - 最后，遍历整个map中，$k$小于等于$a_{min}$的，检查对应的`vector`的$gcd$是否等于$k$，如果是答案就加一。

---

## \[ABC193-E\]过度睡眠

<br>


### 题意

火车在城镇A和城镇B之间循环行驶，过程中包括移动和停留阶段。同时，高桥在火车上有睡眠和清醒的周期。问题是判断高桥能否在清醒时且火车停留在城镇B时下车，并找出最早的可能时间。



### 解法

这是一个同余方程组的问题，需要确定高桥清醒时刻与火车在城镇B停留时刻重合的最小时间。由于周期性的时间安排，我们可以通过枚举火车在B停留的时间与高桥清醒的时间，使用扩展中国剩余定理（EXCRT）求解最小时间点。


1. **定义周期**: 火车周期为 $2X + 2Y$，高桥周期为 $P + Q$，其中火车在B的停留时间定义为周期内的时间段 $[X, X+Y)$，高桥清醒时间为 $[P, P+Q)$。

---

2. **同余方程**: 
   - 根据题意，假设当前时间为$t$，则$t$必须在周期内的时间段 $[X, X+Y)$，同时$t$必须在周期内的时间段 $[P, P+Q)$。
   - 换句话说，$t$模第一个周期的余数，必须在 $[X, X+Y)$，模第二个周期的余数，必须在$[P, P+Q)$。
3. **数学表示**：
   设 $t$ 为高桥可以在B下车的时间，需要满足两个条件:
   - $t \equiv i \pmod{2X + 2Y}$ （$i$ 在 $[X, X+Y)$ 范围内）
   - $t \equiv j \pmod{P + Q}$ （$j$ 在 $[P, P+Q)$ 范围内）

---

### 中国剩余定理简介

中国剩余定理（Chinese Remainder Theorem，简称CRT）是一种在数学中非常有用的定理，主要用于解决一类特殊的数学问题：给定一组同余方程，求解它们的一个共同解。


#### 基本思想

假设你有几个不同的数字，每个数字告诉你一个信息：一个数除以这个数字的余数是多少。例如，如果一个数除以3的余数是2，除以5的余数是3，除以7的余数是2。中国剩余定理可以帮助你找到一个最小的正数，它符合所有这些除法的余数条件。

### 扩展中国剩余定理（EXCRT）

在普通的中国剩余定理中，我们假设所有的模数（即除数）都是互质的，这意味着每两个模数之间没有公共的因数。但在现实中，有时候模数可能不是互质的。这时，就需要使用扩展中国剩余定理来找到一个解。

扩展中国剩余定理允许模数之间有公共因子，需要使用特定的算法来逐步合并这些同余方程。

--- 


4. **枚举与求解**: 枚举$i$范围为$[X, X+Y)$，枚举$j$范围为$[P, P+Q)$对于每个可能的 $i$ 和 $j$，使用扩展中国剩余定理（EXCRT）合并同余方程，求解$t$。如果无解输出 `infinity`，否则输出所有$t$中最小的一个。

